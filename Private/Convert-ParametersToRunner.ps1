function Convert-ParametersToRunner {
    
    # Used to generate run.ps1 file which is executed in Azure Function

    param (
        
        [string[]]$Command,
        [switch]$Invoke,
        [switch]$Clipboard

    )

    BEGIN {
        $Response = @()
        # TODO: Add some info how file was generated?
        $Response += "# run.ps1 auto-generated by EasyAzureFunction module, iricigor@gmail.com","'run.ps1 start'"

        $Prefix = 'Ez'
    }

    PROCESS {

        foreach ($C1 in $Command) { # TODO: Recheck logic for more than one command, check also END block

            Write-Verbose -Message "Processing command $C1"
            $Params = Get-Parameter $C1 

            # generate code to read parameters

            # According to documentation / template POST should give me json formatted parameters, but I got them HTML encoded like Igor=1&Joey=2
            # $Response += '', '# POST method: $req', '$requestBody = Get-Content $req -Raw | ConvertFrom-Json'
            # $Response += "`$InvokeCommand = `$requestBody.InvokeCommand" # reads hidden parameter
            # foreach ($P1 in $Params) {
            #     $Response += "`$$P1 = `$requestBody.$P1"  # output like $url = $req_query_url
            # }

            # TODO: Add some logging options 
            $Response += '', '# POST method: $req', '$requestContent = Get-Content $req -Raw'
            # try to properly parse json response
            $Response += 'try {','  $requestBody = $requestContent | ConvertFrom-Json','  $Failed = $false'
            $Response += '  "Params (JSON): $($requestBody.PSObject.Properties.Name -join `",`")"' # logging to AzF console
            $Response += "  `$$Prefix`InvokeCommand = `$requestBody.$Prefix`InvokeCommand" # reads hidden parameter
            foreach ($P1 in ($Params.Name | Select -Unique)) {$Response += "  `$$Prefix$P1 = `$requestBody.$Prefix$P1"}
            # if fails, try to parse URL encoded params
            $Response += '} catch {$Failed = $true}'
            $Response += 'if ($Failed) {', '"Params (URLEncoded): $requestContent"' # logging to AzF console
            $Response += "  `$requestContent -split '&' | % {","    `$v = `$_ -split '='"
            $Response += '    if ($V[1]) {Set-Variable -Name `$v[0] -Value `$v[1]','  }','}'
            # FIXME: Above not good because any name gets converted to var

            # generate code to open default page
            $Response += '','# prepare output, either default web-page or invoke command'
            $Response += "if (!`$$Prefix`InvokeCommand) {","  'show default web page'", '  cd $EXECUTION_CONTEXT_FUNCTIONDIRECTORY', '  $Output = Get-Content .\index.html -Raw'

            # generate code to invoke command in try catch block, using parameters splatting
            $Response += '} else {',"  'invoke command'", '  try {'
            $Response += "    `$ParamsHash = @{}"
            foreach ($P1 in ($Params | Select -Unique Name, Type)) {
                $N = $P1.Name
                if ($P1.Type -eq 'SwitchParameter') {
                    $Response += "    if (`$$Prefix$N) {`$ParamsHash.Add('$N',`$True)}"
                } else {
                    $Response += "    if (`$$Prefix$N) {`$ParamsHash.Add('$N',`$$Prefix$N)}"
                }                
                # TODO: Handle arrays, etc.
            }
            $Response += '    "Params: $($ParamsHash.Keys -join `",`")"' # logging to AzF console
            $Response += "    `$Output = $C1 @ParamsHash | Out-String"
            $Response += '    if ($Output) {$Color = ''white''}','else {$Color = ''gray''; $Output = ''Command run successfully, but it returned no output''}'
            $Response += '  } catch {','    $Output = $_','    $Color = ''red''','  }' # TODO: Sometimes not working, error crashes web app

            $Response += '  $Head = ''<head><style>body {background-color: #012456; color: $Color;}</style></head>'''
            $Response += "  `$Output = `$Head + '<pre>' + `$Output + '</pre>'","  `$Output = `$Output -replace `"``n`",'</br>'",'}'
                        
            # convert output to HTML and parse it back
            $Response += '', '# parse and send back output'
            $Response += "`$Output2 = [PSCustomObject]@{Status = 200; Body = '';  Headers = @{}}","`$Output2.Headers.Add('content-type','text/html')"
            $Response += "`$Output2.Body = `$Output -replace '`"',`"'`""

            $Response += '','Out-File -Encoding utf8 -FilePath $res -inputObject ($Output2 | ConvertTo-JSON)'
        }
    }

    END {
        if ($Clipboard) {
            $Response | Set-Clipboard
        } elseif ($Invoke) {
            $TempFile = [System.IO.Path]::GetTempFileName() + '.txt'
            $Response | Out-File $TempFile
            Invoke-Item $TempFile
        } else {
            $Response
        }
    }
}