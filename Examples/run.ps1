# run.ps1 auto-generated by EasyAzureFunction module, iricigor@gmail.com
'run.ps1 start'

# POST method: $req
$requestBody = Get-Content $req -Raw
$requestBody -split '&' | % {
  $v = $_ -split '='
  Set-Variable -Name $v[0] -Value $v[1]
}
#$requestBody = Get-Content $req -Raw | ConvertFrom-Json
#$InvokeCommand = $requestBody.InvokeCommand
#$Name = $requestBody.Name
#$Verb = $requestBody.Verb
#$Noun = $requestBody.Noun
#$Module = $requestBody.Module
#$FullyQualifiedModule = $requestBody.FullyQualifiedModule
#$CommandType = $requestBody.CommandType
#$TotalCount = $requestBody.TotalCount
#$Syntax = $requestBody.Syntax
#$ShowCommandInfo = $requestBody.ShowCommandInfo
#$ArgumentList = $requestBody.ArgumentList
#$All = $requestBody.All
#$ListImported = $requestBody.ListImported
#$ParameterName = $requestBody.ParameterName
#$ParameterType = $requestBody.ParameterType

# prepare output, either default web-page or invoke command
if (!$InvokeCommand) {
  'show default web page'
  cd $EXECUTION_CONTEXT_FUNCTIONDIRECTORY
  $Output = Get-Content .\index.html -Raw
} else {
  'invoke command'
  try {
    $ParamsHash = @{}
    if ($Name) {$ParamsHash.Add('Name',$Name)}
    if ($Verb) {$ParamsHash.Add('Verb',$Verb)}
    if ($Noun) {$ParamsHash.Add('Noun',$Noun)}
    if ($Module) {$ParamsHash.Add('Module',$Module)}
    if ($FullyQualifiedModule) {$ParamsHash.Add('FullyQualifiedModule',$FullyQualifiedModule)}
    if ($CommandType) {$ParamsHash.Add('CommandType',$CommandType)}
    if ($TotalCount) {$ParamsHash.Add('TotalCount',$TotalCount)}
    if ($Syntax) {$ParamsHash.Add('Syntax',$Syntax)}
    if ($ShowCommandInfo) {$ParamsHash.Add('ShowCommandInfo',$ShowCommandInfo)}
    if ($ArgumentList) {$ParamsHash.Add('ArgumentList',$ArgumentList)}
    if ($All) {$ParamsHash.Add('All',$All)}
    if ($ListImported) {$ParamsHash.Add('ListImported',$ListImported)}
    if ($ParameterName) {$ParamsHash.Add('ParameterName',$ParameterName)}
    if ($ParameterType) {$ParamsHash.Add('ParameterType',$ParameterType)}
    $Output = Get-Command @ParamsHash | Out-String
  } catch {
    $Output = $_ | Out-String
  }
  $Output = '<pre>' + $Output + '</pre>'
  $Output = $Output -replace "`n",'</br>'
}

# parse and send back output
#$Output2 = [string]::Format('{{ "Body": "{0}", "Headers": {{"content-type": "text/html" }} }}', $Output)
#$Output2 = [string]::Format('{{ "Status": 200, "Body": "{0}", "Headers": {{"content-type": "text/html" }} }}', $Output -replace '"',"'")
#$Output2 = [string]::Format('{{ "Status": 200, "Body": "{0}", "Headers": {{"content-type": "text/html" }} }}', [System.Web.HttpUtility]::HtmlEncode($Output))
$Output2 = [pscustomobject]@{Status = 200; Body = '';  Headers = @{}}
$Output2.Body = $Output -replace '"',"'"
$Output2.Headers.Add('content-type','text/html')

Out-File -Encoding utf8 -FilePath $res -inputObject ($Output2 | ConvertTo-Json)